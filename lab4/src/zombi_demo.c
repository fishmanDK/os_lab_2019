#include <stdio.h>  
 #include <stdlib.h>   
 #include <unistd.h>   
 #include <sys/types.h> 
 #include <sys/wait.h> 
 
 int main() {
     /* 
      * Создаем дочерний процесс.
      * После вызова fork() программа "разветвляется" на два идентичных процесса,
      * которые продолжают выполнение с этой точки.
      * Возвращаемые значения:
      * - В дочернем процессе: 0
      * - В родительском: PID дочернего процесса
      * - -1 в случае ошибки
      */
     pid_t pid = fork();
 
     /* Обработка ошибки создания процесса */
     if (pid < 0) {
         // Выводим сообщение об ошибке с описанием (perror)
         perror("fork failed");
         // Завершаем программу с кодом ошибки
         exit(1);
     }
 
     /* Блок кода для дочернего процесса */
     if (pid == 0) {
         // Выводим PID дочернего процесса
         printf("Child process (PID: %d) is sleeping for 2 seconds...\n", getpid());
         
         /* 
          * Имитируем работу процесса (например, вычисления или ожидание)
          * sleep() приостанавливает выполнение на указанное количество секунд
          */
         sleep(2);
         
         // Сообщение о завершении работы
         printf("Child process (PID: %d) is exiting...\n", getpid());
         
         /* 
          * Явно завершаем дочерний процесс с кодом 0 (успешное завершение)
          * Если не вызвать exit(), процесс продолжит выполнение родительского кода!
          */
         exit(0);
     }
     /* Блок кода для родительского процесса */
     else {
         // Выводим PID родительского процесса
         printf("Parent process (PID: %d) is waiting for child to exit...\n", getpid());
         
         /*
          * Даем время дочернему процессу завершиться.
          */
         sleep(5);
         
         printf("Parent process (PID: %d) is now calling wait().\n", getpid());
         
         /* 
          * wait(NULL) ожидает завершения ЛЮБОГО дочернего процесса.
          * NULL означает, что мы не сохраняем статус завершения.
          * Эта функция:
          * 1. Блокирует выполнение, пока дочерний процесс не завершится
          * 2. "Убирает" запись о завершенном процессе из системы (превращает зомби в умерший процесс)
          */
         wait(NULL);
         
         // Подтверждение, что зомби-процесс был убран
         printf("Zombie process has been reaped.\n");
     }
 
     // Завершение родительского процесса
     return 0;
 }